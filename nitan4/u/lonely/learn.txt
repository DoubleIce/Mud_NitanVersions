/*
& 按位与 
| 按位或 
^ 按位异或 
~ 按位求反       
4.就是1变成0,0变成1  
12先转二进制是00001100 
再取反后得11110011 
转换补码-1 11110011-1=11110010 
再取反得10001101=十进制的-13 

1. 按位与运算 按位与运算符"&"是双目运算符。其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1 ，否则为0。参与运算的数以补码方式出现。 
例如：9&5可写算式如下： 00001001 (9的二进制补码)&00000101 (5的二进制补码) 00000001 (1的二进制补码)可见9&5=1。 
按位与运算通常用来对某些位清0或保留某些位。例如把a 的高八位清 0 ， 保留低八位， 可作 a&255 运算 ( 255 的二进制数为0000000011111111)。 
main(){ 
int a=9,b=5,c; 
c=a&b; 
printf("a=%d\nb=%d\nc=%d\n",a,b,c); 
} 
2. 按位或运算 按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1。参与运算的两个数均以补码出现。 
例如：9|5可写算式如下： 00001001|00000101 
00001101 (十进制为13)可见9|5=13 
main(){ 
int a=9,b=5,c; 
c=a|b; 
printf("a=%d\nb=%d\nc=%d\n",a,b,c); 
} 
3. 按位异或运算 按位异或运算符“^”是双目运算符。其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。参与运算数仍以补码出现，例如9^5可写成算式如下： 00001001^00000101 00001100 (十进制为12) 
main(){ 
int a=9; 
a=a^15; 
printf("a=%d\n",a); 
}

位运算符 
C提供了六种位运算运算符；这些运算符可能只允许整型操作数，即char、short、int和long，无论signed或者unsigned。 
& 按位AND 
| 按位OR 
^ 按位异或 
<< 左移 
>> 右移 
~ 求反（一元运算） 
按位与操作&通常用于掩去某些位，比如 
n = n & 0177; 
使得n中除了低7位的各位为0。 
按位或操作|用于打开某些位： 
x = x | SET_ON; 
使得x的某些SET_ON与相对的位变为1。 
按位异或操作^使得当两个操作数的某位不一样时置该位为1，相同时置0。 
应该区分位操作符&、|与逻辑操作符&&、||，后者从左到右的评价一个真值。比如，如果x为1、y为2，那么x & y为0，而x && y为1。 
移位运算符<<和>>将左侧的操作数左移或者右移右操作数给定的数目，右操作数必须非负。因此x << 2将x的值向左移动两位，用0填充空位；这相当于乘4。右移一个无符号数会用0进行填充。右移一个带符号数在某些机器上会用符号位进行填充（“算数移位”）而在其他机器上会用0进行填充（“逻辑移位”）。 
单目运算符~对一个整数求反；即将每一个1的位变为0，或者相反。比如 
x = x & ~077 
将x的后六位置0。注意x & ~077的值取决于字长，因此比如如果假设x是16位数那么就是x & 0177700。这种简易型式并不会造成额外开销，因为~077是一个常数表达式，可以在编译阶段被计算。 
作为一个使用位操作的实例，考虑函数getbits(x,p,n)。它返回以p位置开始的n位x值。我们假设0位在最右边，n和p是正数。例如，getbits(x,4,3)返回右面的4、3、2位。 
getbits: 返回从位置p开始的n位  
unsigned getbits(unsigned x, int p, int n) 
{ 
return (x >> (p+1-n)) & ~(~0 << n); 
} 
表达式x >> (p+1-n)将需要的域移动到字的右侧。~0是全1；将其左移n为并在最右侧填入0；用~使得最右侧n个1成为掩码。 
*/
